// --- User model
const userSchema = new mongoose.Schema(
  {
    studentId: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      validate: {
        // Format: 03-2324-032246 (2-4-6 digits with hyphens)
        validator: v => STUDENT_ID_REGEX.test(v),
        message: 'Student ID must match 00-0000-000000 pattern'
      }
    },
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
      validate: {
        validator: v => validator.isEmail(v), // contains '@' and valid format
        message: 'Email must be a valid address'
      }
    },
    // Some existing collections may expect a `name` field; keep both.
    name: { type: String, trim: true },
    fullName: {
      type: String,
      required: true,
      trim: true,
      validate: {
        // Allow letters, spaces, periods, apostrophes, and hyphens
        validator: v => /^[A-Za-z .'-]+$/.test(v),
        message: "Full name may contain letters, spaces, apostrophes, hyphens, and periods only"
      }
    },
    barcode: { type: String, trim: true, unique: true, sparse: true },
    passwordHash: { type: String, required: true },
    role: { type: String, trim: true, default: 'student' },
    status: { type: String, enum: ['active','disabled','pending'], default: 'active' }
  },
  { timestamps: true }
);

// Field-level unique indexes are already defined on email and studentId.
// Avoid duplicating them with schema.index() to prevent Mongoose warnings.

const User = mongoose.model('User', userSchema);

// Separate Admin collection
const adminSchema = new mongoose.Schema(
  {
    adminId: { type: String, required: true, unique: true, trim: true },
    email: { type: String, trim: true, lowercase: true, unique: true, sparse: true },
    fullName: { type: String, required: true, trim: true },
    passwordHash: { type: String, required: true },
    role: { type: String, enum: ['librarian', 'librarian_staff'], default: 'librarian_staff' },
    status: { type: String, enum: ['active','disabled','pending'], default: 'active' }
  },
  { timestamps: true }
);
const Admin = mongoose.model('Admin', adminSchema);

async function ensureDefaultAdmin() {
  const rawEmail = process.env.ADMIN_EMAIL || 'admin@example.com';
  const email = rawEmail ? String(rawEmail).trim().toLowerCase() : '';
  const adminId = String(process.env.ADMIN_ID || process.env.ADMIN_STUDENT_ID || '03-2324-03224').trim();
  const fullName = String(process.env.ADMIN_NAME || 'Librarian').trim() || 'Librarian';
  const password = process.env.ADMIN_PASSWORD || 'Password123';

  const lookups = [];
  if (adminId) lookups.push({ adminId });
  if (email) lookups.push({ email });

  const existing = lookups.length ? await Admin.findOne({ $or: lookups }).lean() : null;
  if (existing) {
    const updates = {};
    if (email && !existing.email) updates.email = email;
    if (existing.role !== 'librarian') updates.role = 'librarian';
    if (adminId && existing.adminId !== adminId && STUDENT_ID_REGEX.test(adminId)) {
      updates.adminId = adminId;
    }
    if (Object.keys(updates).length) {
      await Admin.updateOne({ _id: existing._id }, { $set: updates });
    }
    return;
  }

  const passwordHash = await bcrypt.hash(String(password), 10);
  const toCreate = {
    adminId,
    fullName,
    role: 'librarian',
    passwordHash
  };
  if (email) toCreate.email = email;

  try {
    await Admin.create(toCreate);
    console.log(`Created default admin (librarian) with Admin ID ${adminId}`);
  } catch (err) {
    if (err && (err.code === 11000 || err.code === 11001)) {
      console.warn('Default admin already exists, skipping bootstrap account creation.');
    } else {
      throw err;
    }
  }
}

// --- Additional models ---
const bookSchema = new mongoose.Schema(
  {
    title: { type: String, required: true, trim: true },
    author: { type: String, required: true, trim: true },
    isbn: { type: String, trim: true },
    // Unique index for bookCode is defined below via schema.index to avoid duplicate-index warnings
    bookCode: { type: String, trim: true },
    genre: { type: String, trim: true },
    tags: [{ type: String, trim: true }],
    totalCopies: { type: Number, default: 1, min: 0 },
    availableCopies: { type: Number, default: 1, min: 0 },
    coverImagePath: { type: String, trim: true },
    coverImageOriginalName: { type: String, trim: true },
    coverImageFileId: { type: mongoose.Schema.Types.ObjectId },
    coverImageMime: { type: String, trim: true },
    pdfPath: { type: String, trim: true },
    pdfOriginalName: { type: String, trim: true },
    pdfFileId: { type: mongoose.Schema.Types.ObjectId },
    pdfMime: { type: String, trim: true }
  },
  { timestamps: true }
);
bookSchema.index({ title: 'text', author: 'text' });
// Ensure uniqueness at the index level (not in the field), to prevent duplicate schema index warnings
bookSchema.index({ bookCode: 1 }, { unique: true, sparse: true });
const Book = mongoose.model('Book', bookSchema);

const loanSchema = new mongoose.Schema(
  {
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    bookId: { type: mongoose.Schema.Types.ObjectId, ref: 'Book', required: true },
    borrowedAt: { type: Date, default: () => new Date() },
    dueAt: { type: Date, required: true },
    returnedAt: { type: Date, default: null }
  },
  { timestamps: true }
);
loanSchema.index({ userId: 1, returnedAt: 1 });
loanSchema.index({ bookId: 1, returnedAt: 1 });
loanSchema.index({ dueAt: 1 });
const Loan = mongoose.model('Loan', loanSchema);

const visitSchema = new mongoose.Schema(
  {
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    studentId: { type: String, trim: true },
    barcode: { type: String, trim: true },
    branch: { type: String, trim: true, default: 'Main' },
    enteredAt: { type: Date, default: () => new Date() },
    exitedAt: { type: Date, default: null }
  },
  { timestamps: true }
);
visitSchema.index({ studentId: 1, enteredAt: -1 });
visitSchema.index({ barcode: 1, enteredAt: -1 });
visitSchema.index({ userId: 1, enteredAt: -1 });
const Visit = mongoose.model('Visit', visitSchema);

const hoursSchema = new mongoose.Schema(
  {
    branch: { type: String, required: true, trim: true },
    dayOfWeek: { type: Number, required: true, min: 0, max: 6 }, // 0=Sun
    open: { type: String, required: true }, // HH:mm
    close: { type: String, required: true }
  },
  { timestamps: true }
);
hoursSchema.index({ branch: 1, dayOfWeek: 1 }, { unique: true });
const Hours = mongoose.model('Hours', hoursSchema);

// Password reset tokens
const passwordResetSchema = new mongoose.Schema(
  {
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    tokenHash: { type: String, required: true },
    createdAt: { type: Date, default: () => new Date() },
    expiresAt: { type: Date, required: true },
    used: { type: Boolean, default: false },
    usedAt: { type: Date, default: null }
  },
  { timestamps: false }
);
passwordResetSchema.index({ userId: 1, expiresAt: 1, used: 1 });
const PasswordReset = mongoose.model('PasswordReset', passwordResetSchema);

